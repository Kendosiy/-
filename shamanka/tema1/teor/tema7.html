<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link href="../../style.css" rel="stylesheet">
	</head>
	<body>
		<header>
			<div>
				<a href="../../index.html"><h1>Учебный портал</h1></a>
			</div>
			<nav>
					<ul class="main_menu">
					<li>
						<a href="#"><p>Справочные материалы </p></a>
						<ul class="submenu" id="sub1">
							<li><a href="../../delphi-lab-teor.html">Теория по Delphi</a></li>
						</ul>
					</li>
					<li>
						<a href="#"><p>Лабораторные работы </p></a>
						<ul class="submenu" id="sub2">
							<li><a href="../../delphi-lab-prac.html">Задания по Delphi</a></li>
						</ul>
					</li>
				</ul>
			</nav>
		</header>
		<main>
			<div class="prev"><a href="tema6.html"><img src="../../res/prev.png"></a></div>
			<div class="next"><a href="tema8.html"><img src="../../res/next.png"></a></div>
			<aside id="sidebar">
				<h2>Быстрая навигация</h2>
				<ol>
					<li><a href="#1">Порядковые типы</a></li>
					<li><a href="#2">Целые типы</a></li>
					<li><a href="#3">Символьные типы</a></li>
					<li><a href="#4">Булевы типы</a></li>
					<li><a href="#5">Перечислимые типы</a></li>
					<li><a href="#6">Поддиапазонные типы</a></li>
					<li><a href="#7">Действительные типы</a></li>
				</ol>
			</aside>
			<article class="tema">
				<h2>
					Типы данных
				</h2>
				<p>
					С помощью типов данных программист указывает компилятору, как хранить
					информацию в программе. При объявлении переменной необходимо указать ее
					тип. Одни типы уже определены в языке, другие программисту приходится
					задавать самому. В ранних языках программирования допускалось ограниченное
					число типов данных, и Pascal оказался одним из первых языков, допускающих
					определение в программе новых типов.
					<br/>
					Типы данных, определяемые пользователем, обычно задаются в разделе
					определения типов программы или модуля (unit), однако это можно делать и
					внутри процедур или функции. Объявления типов действуют в пределах того
					блока, в котором они размещены. Вне этого блока ссылаться на такие типы
					нельзя. Внутри же они заменяют все внешние типы с тем же именем.
					Объявленные типы данных можно применять в любом месте области их видимости;
					запрещена только ссылка определяемого типа на самого себя (тут, однако,
					есть одно исключение, касающееся указателей).
					<br/>
					Объявления типов в Pascal являются для компилятора чем-то вроде схем,
					которые он должен запомнить на случай, если вдруг встретит в программе
					ссылки на тот или иной тип. Само по себе объявление типа не вносит в
					программу никаких изменений.
					<br/>
					Что же касается объявлений var, то они задают компилятору некоторые
					действия, связанные с ранее объявленными типами. Тип переменной
					ограничивает как ее значения, так и операции, которые можно выполнять с
					этими значениями.
					<br/>
					Определения типов и переменных могут размещаться в нескольких местах
					компонентов программы. Выглядят же они следующим образом.

				</p>
				<code>
					<pre>
type
typel = type definition1;		//Новые типы данных определяются в разделе "type".
					  Каждому новому типу присваивается имя, затем он определяется 
					  через уже существующие типы.
type2 = type__definition2;		//В одном разделе "type" можно объявить несколько типов. 
					  Самое простое определение типа состоит из имени типа, 
					  type3 = typel; определенного ранее.
var 					//Новые переменные объявляются в разделе "var". 
var1: type definitions; 		  Каждой новой переменной сначала присваивается имя, 
					  а затем - тип (на основе ранее определенных типов).
var2, var3: type definition4; 		//В одном разделе "var" можно объявить несколько переменных.
					  Нескольким переменным можно присваивать один и тот же тип.
var4 : typel; 				//Программу легче читать, если присвоены существующие типы.
					</pre>
				</code>
				<p>
					Синтаксис Object Pascal позволяет одновременно конструировать исключительно
					сложные типы и определение переменных. Однако определение типов в разделах
					type тех или иных блоков дает возможность использовать эти типы в разных
					частях программы. Новые типы определяются из типов следующих категории.
					<br/>

				</p>
				<ul>
					<li>
						Простые типы для хранения информации в форме чисел и других
						"упорядоченных" значении.
					</li>
					<li>
						Строковые типы для хранения последовательностей символов.
					</li>
					<li>
						Структурные типы для одновременного хранения информации разных
						типов.
					</li>
					<li>
						Указательные типы для косвенного обращения к переменным заданных
						типов.
					</li>
					<li>
						Процедурные типы для обращения к процедурам и функциям,
						рассматриваемым как переменные.
					</li>
					<li>
						Вариантные типы для хранения в одной переменной данных различных
						типов.
					</li>
				</ul>
				<p>
					Обычно идентификаторы типов используются только при определении новых типов
					или объявлении переменных. Есть, однако, несколько функций, в которых имя
					типа может использоваться как часть выполняемого оператора. Например,
					функция SizeOf (Т) возвращает количество байтов, занимаемых переменной Т.
					<br/>
					Функция SizeOf очень важна для написания эффективных программ. Многие из
					определенных в Object Pascal типов имеют очень сложную структуру и могут
					занимать в памяти довольно много места. При этом элементы таких типов
					созданы скорее для представления значений в некотором логическом порядке, а
					не для того, чтобы занимать место в памяти. Функция SizeOf избавляет
					программиста от необходимости вычислять объем данных в подобных случаях.

				</p>
				<p>
					<h2>Простые типы данных</h2>
					<br/>

				</p>
				<p>
					Любой реально существующий тип данных, каким бы сложным он ни казался на
					первый взгляд, представляет собой простые составляющие, которыми процессор
					может манипулировать. В Object Pascal эти простые типы данных разбиты на
					две группы: порядковые, представляющие данные разных объемов, которыми
					процессор может легко манипулировать, и действительные, представляющие
					приближенно математические действительные числа. Разделение типов на
					порядковые и действительные несколько условно. Точно так же простые данные
					можно было бы разделить на числа и не числа. Однако в языке Object Pascal
					порядковые и действительные данные трактуются по-разному, и такое
					разделение даже полезно.
					<br/>

				</p>
				<p>
					<a name="1"></a>
					<strong>Порядковые типы</strong>
					<br/>
					Из простых типов данных порядковые - самые простые. В этих типах информация
					представляется в виде отдельных элементов. Связь между отдельными
					элементами и их представлением в памяти определяет естественные отношения
					порядка между этими элементами. Отсюда и название порядковые.
					<br/>
					В Object Pascal определены три группы порядковых типов и два типа,
					определяемых пользователем. Группы - это целые, символьные и булевы типы.
					Порядковые типы, задаваемые пользователем, - это перечисления и
					поддиапазоны.
					<br/>
					Все значения любого порядкового типа образуют упорядоченную
					последовательность, и значение переменной порядкового типа определяется его
					местом в этой последовательности. За исключением переменных целых типов,
					значения которых могут быть как положительными, так и отрицательными,
					первый элемент любого порядкового типа имеет номер 0, второй элемент -
					номер 1 и т.д. Порядковый номер целого значения равен самому значению.
					Отношение порядка определяет общие для данных всех порядковых типов
					операции. Некоторые стандартные функции такого вида встроены в Object
					Pascal. Они представлены в табл. 1.1.
					<br/>

				</p>
				<p>
					Для всех порядковых типов в Object Pascal существует операция задания типа
					для преобразования целых значений в значения соответствующих порядковых
					типов. Если Т - имя порядкового типа, а Х - целое выражение, то Т (X)
					воз-вращает значение Т с порядковым номером X.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					Программисты, работающие на С и C++, для приращения или уменьшения значений
					переменных привыкли заметку использовать операторы "++" и "--",
					возвращающие следующее и предыдущее значения. Программисты Delphi всегда
					разбивают эти операции на более простые составляющие с помощью функций
					Pred, Succ. Dec и Inc.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>

				</p>
				<p>
					<strong>Таблица 1.1.</strong>
					Операции над порядковыми типами

				</p>
				<p>

				</p>
				<div align="right">
					<table border="1" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										<strong>Операция</strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong> Описание</strong>
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Low (T)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Минимальное значение порядкового типа Т
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										High(T)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Максимальное значение порядкового типа Т
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Ord(X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Порядковый номер значения выражения порядкового типа.
										Для целого выражения - просто его значение. Для
										остальных порядковых типов Ord возвращает физическое
										представление результата выражения, трактуемое как
										целое число. Возвращаемое значение всегда принадлежит
										одному из целых типов
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Pred(X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Предыдущее по порядку значение. Для целых выражений
										эквивалентно Х-1
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Succ(X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Следующее по порядку значение. Для целых выражений
										эквивалентно Х+1
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Dec(V)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Уменьшает значение переменной на 1. Эквивалентно V :=
										Pred(V)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Inc(V)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Увеличивает значение переменной на 1. Эквивалентно V :=
										Succ(V)
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>

				</p>
				<p>
					<a name="2"></a>
					<strong>Целые типы</strong>
					<br/>
					В переменных целых типов информация представляется в виде целых чисел, т.е.
					чисел не имеющих дробной части. Определенные в Object Pascal целые типы
					подразделяются на физические (фундаментальные) и логические (общие). При
					программировании удобнее использовать логические целые типы, которые задают
					объем переменных в зависимости от типа микропроцессора и операционной среды
					таким образом, чтобы достигалась максимальная эффективность. Физические
					целые типы следует применять лишь в тех случаях, когда в первую очередь
					важны именно диапазон значений и физический объем переменной. В Object
					Pascal определены следующие целые типы.
					<br/>

				</p>
				<p>
					Integer
					<br/>
					Shortint
					<br/>
					Smallint
					<br/>
					Longint
					<br/>
					Byte
					<br/>
					Word
					<br/>
					Cardinal

				</p>
				<p>
					Обратите внимание, что один из этих целых типов назван именно целым
					(integer). Это может иногда приводить к путанице, но мы легко сможем ее
					избежать, применяя термин целый к. группе типов, a integer - к конкретному
					типу, определяемому в программе этим ключевым словом. Переменные физических
					целых типов имеют разные диапазоны значений в зависимости от того, сколько
					байтов памяти они занимают (что равно значению, возвращаемому функцией
					SizeOf для данного типа). Диапазоны значений для всех физических типов
					перечислены в табл. 1.2.
					<br/>

				</p>
				<p>
					<strong>Таблица 1.2. </strong>
					Физические целые типы

				</p>
				<p>

				</p>
				<div align="right">
					<table border="1" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										<strong>Тип </strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Диапазон значении</strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Физический формат</strong>
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Shortint
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										-128-127
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										8 бит, со знаком
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Smallint
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										-32 768-32 767
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										16 бит, со знаком
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Longint
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										-2 147 483 648-2 147 483 647
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										32 бит, со знаком
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Byte
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										0-255
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										8 бит, без знака
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Word
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										0-65 535
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										16 бит, без знака
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>
					Диапазоны значений и форматы физических целых типов не зависят от
					микропроцессора и операционной системы, в которых выполняется программа.
					Они не меняются (или, по крайней мере, не должны меняться) с изменением
					реализации или версии Object Pascal.
					<br/>
					Диапазоны значений логических целых типов (Integer и Cardinal) определяются
					совершенно иным образом. Как видно из табл. 1.3, они никак не связаны с
					диапазонами соответствующих физических типов. Обратите внимание, что в
					Delphi по умолчанию задано 32-разрядное представление.
					<br/>

				</p>
				<p>
					<strong>Таблица 1.3. </strong>
					Логические целые типы

				</p>
				<p>

				</p>
				<div align="right">
					<table border="1" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										Тип
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Диапазон значений
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Физический формат
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Integer
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										-32 768-32 767
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										16 бит, со знаком (SmalIInt)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Integer
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										-2 147 483 648-2 147 483 647
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										32 бит, со знаком (Longint)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Cardinal
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										0-65 535
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										16 бит, без знака (Word)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Cardinal
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										0-2 147483647
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										32 бит, без знака (Longint)
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					В С и C++ для целых значений определены типы int, short int (или просто
					short) и long int (или просто long). Тип int из C/C++ соответствует типу
					Integer из Delphi, a long из C/C++ - Longint из Delphi. Однако Shortint из
					C/C++ соответствует в Delphi не Shortint, a Smalltlnt. Эквивалент Shortint
					из Delphi в C/C++- это signed char. Тип unsigned char в C/C++ соответствует
					типу Byte из Delphi. В C/C++ существует еще тип unsigned long, аналога
					которому в Delphi нет.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					Над целыми данными выполняются все операции, определенные для порядковых
					типов, но с ними все же удобнее работать как с числами, а не с
					"нечисленными порядковыми типами". Как и "живые" числа, данные целых типов
					можно складывать (+), вычитать (-) и умножать (*). Однако некоторые
					операции и функции, применяемые к данным целых типов, имеют несколько иной
					смысл.
					<br/>

				</p>
				<div align="right">
					<table border="0" cellspacing="0" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										<strong>Операция</strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Результат</strong>
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Abs (X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Возвращает абсолютное целое значение Х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Х Div Y
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Возвращает целую часть частного деления Х на Y
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Х Mod Y
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Возвращает остаток частного деления Х на Y
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Odd (X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Возвращает булево True (истина), если Х - нечетное
										целое, и False (ложь) - в противном случае
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Sqr (X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Возвращает целый квадрат Х (т.е. Х*Х)
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					Будьте внимательны при перенесении численных выражений из одного языка в
					другой. В Basic, например,vфункция SQR вычисляет квадратный корень. В C/C++
					целое деление обозначается косой чертой (/). В Delphi косая между двумя
					целыми даст действительный результат с плавающей запятой.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<a name="3"></a>
					<strong>Символьные типы</strong>
					<br/>
					Смысл символьных данных очевиден, когда они выводятся на экран или принтер.
					Тем не менее, определение символьного типа может зависеть от того, что
					подразумевать под словом символ. Обычно символьные типы данных задают схему
					взаимодействия между участками памяти разного объема и некоторым
					стандартным методом кодирования/декодирования для обмена символьной
					информацией. В классическом языке Pascal не задано никакой схемы, и в
					конкретных реализациях применялось то, что на том же компьютере мог
					использовать каждый.
					<br/>
					В реализациях языка Pascal для первых микропроцессоров была применена
					7-битовая схема, названная ASCII (American Standard Code for Information
					Interchange - Американский стандартный код для обмена информацией). Эта
					схема и поныне широко распространена, но информация хранится, как правило,
					в 8-битовых участках памяти. Дополнительный бит удваивает число возможных
					представлений символов, но реализации расширенного набора символов ASCII
					часто бывают далеки от стандарта. В данной версии Delphi определен набор
					8-битовых символов, известный как расширенный (extended) ANSI (American
					National Standards Institute - Американский национальный институт
					стандартов). Как бы то ни было, символьную схему приходится воспринимать
					так, как ее воспринимает операционная система. Для оконных операционных
					систем фирмы Microsoft это схема ANSI, включающая ограниченное число
					предназначенных для вывода международных знаков. В стремлении же применить
					более обширный набор международных знаков весь компьютерный мир переходит к
					16-битовой схеме, именуемой UNICODE, в которой первые 256 знаков совпадают
					с символами, определенными в схеме ANSI.
					<br/>
					Для совместимости со всеми этими представлениями в Object Pascal определены
					два физических символьных типа и один логический.
					<br/>
					Физические типы перечислены ниже.
					<br/>

				</p>
				<div align="right">
					<table border="0" cellspacing="0" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										AnsiChar
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Однобайтовые символы, упорядоченные в соответствии с
										расширенным набором символов ANSI
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										WideChar
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Символы объемом в слово, упорядоченные в соответствии с
										международным набором символов UNICODE. Первые 256
										символов совпадают с символами ANSI
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>
					Символьные типы объемом в двойное слово (32 бит) отсутствуют.
					<br/>
					Логический символьный тип именуется char. В классическом языке Pascal char-
					единственный символьный тип. В Delphi char всегда соответствует физическому
					типу данных AnsiChar. У американских программистов ассоциация символа с
					однобайтовой ячейкой памяти укоренилась за долгие годы настолько, что им
					зачастую просто не приходит в голову, что можно использовать другие схемы
					кодирования. Однако дискуссии по интернационализации программ в Internet и
					World Wide Web могут существенно изменить их отношение к проблеме объема
					символьных данных. Применяя логический тип char, следует делать реализации
					для других микропроцессоров и операционных систем, в которых char может
					определяться как WideChar. При написании программ, которые могут
					обрабатывать строки любого размера, для указания этого размера
					рекомендуется применять функцию SizeOf, не задавая ее жестко постоянной.
					Функция Ord (С), где С - любая переменная символьного типа, возвращает
					целое значение, которым символ С представлен в памяти.
					<br/>

				</p>
				<div align="right">
					<table border="0" cellspacing="0" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										Chr (X)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Преобразует целую переменную в переменную типа char с
										тем же порядковым номером. В Delphi это эквивалентно
										заданию типа Char (X)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										UpCase
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Преобразует строчную букву в прописную
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					Процессор не различает типы char, определенные в C/C++ и Delphi. Однако
					функционально каждый из этих языков трактует данный тип совершенно
					по-разному. В C/C++ это целый тип, переменной которого можно присваивать
					целые значения. Переменной int можно присвоить символьное значение, а
					переменной char - целое. В Delphi символьные типы жестко отделены от
					численных. Для присвоения численному значению символьного здесь необходимо
					воспользоваться функцией Ord. В языке Basic один символ представляется так
					же, как и строка символов. Функция Chr из Delphi эквивалентна функции CHR$
					из Basic. Функция Ord из Delphi, возвращающая код ANSI символьной
					переменной, подобна функции A3 С из Basic, аргумент которой представляет
					односимвольную строку.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<a name="4"></a>
					<strong>Булевы типы</strong>
					<br/>
					На ранней стадии обучения программисты осваивают понятие бита, два
					состояния которого можно использовать для записи информации о чем-либо,
					представляющем собой одно из двух. Бит может обозначать 0 или 1, ДА или
					НЕТ, ВКЛЮЧЕНО или ВЫКЛЮЧЕНО, ВЕРХ или НИЗ, СТОЯТЬ или ИДТИ. В Object Pascal
					информация о чем-либо, что можно представить как ИСТИНА (True) или ЛОЖЬ
					(False), хранится в переменных булевых типов. Всего таких типов че-тыре, и
					они представлены в табл. 1.4.
					<br/>

				</p>
				<p>
					<strong>Таблица 1.4. </strong>
					Размеры переменных булевых типов

				</p>
				<p>

				</p>
				<div align="right">
					<table border="1" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										Тип
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Размер
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Boolean
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1 байт
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										ByteBool
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1 байт
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										WordBool
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										2 байт (объем Word)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										LongBool
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										4 байт (объем Longint)
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p>
					По аналогии с целыми и символьными типами, подразделяющимися на физические
					и логические, естественно предположить, что ByteBool, WordBool и LongBool -
					физические типы, Boolean - логический. Но в данном случае это не совсем
					так. Все четыре типа различны. Для Object Pascal предпочтителен тип
					Boolean, остальные определены для совместимости с другими языками
					программирования и операционными системами.
					<br/>
					Переменным типа Boolean можно присваивать только значения True (истина) и
					False (ложь). Переменные ByteBool, WordBool и LongBool могут принимать и
					другие порядковые значения, интерпретируемые обычно как False в случае нуля
					и True - при любом ненулевом значении.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					Булевы типы в Delphi можно сравнить с типом LOGICAL языка FORTRAN. В Basic,
					С и C++ булевы типы как таковые отсутствуют. Булевы выражения в этих языках
					применяются точно так же, как во всех остальных, однако результаты этих
					выражений интерпретируются не как значения отдельного типа, а как целые
					числа. Как в Basic, так и в C/C++ булевы выражения дают численные
					результаты, интерпретируемые как False в случае 0 и True - в случае любого
					ненулевого значения. Это совместимо с порядковыми значениями булевых
					выражений в Delphi. В C/C++ простые сравнения дают результат 1 (True) или 0
					(False). Это эквивалентно булевым значениям Delphi. Только результат
					сравнения в Delphi выводится как булевый, а не целый. В большинстве случаев
					типу Boolean из Delphi соответствует тип char в C/C++. В Basic
					зарезервированы слова TRUE (эквивалентно константе -1) и FALSE
					(эквивалентно константе 0). В Basic TRUE меньше FALSE, в Delphi, наоборот,
					False меньше True.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<a name="5"></a>
					<strong>Перечислимые типы</strong>
					<br/>
					Type enum type = (first value, value2, value3, last value);
					<br/>
					Обычно данные перечислимых типов содержат дискретные значения,
					представляемые не числами, а именами. Тип Boolean- простейший перечислимый
					тип в Object Pascal. Булевы переменные могут принимать два значения,
					выражаемые именами True и False, а сам тип определен в Object Pascal так,
					как будто он объявлен следующим образом:
					<br/>
					Type Boolean = (False, True);
					<br/>
					С помощью типа Boolean в Object Pascal выполняются сравнения, большинство
					же перечислимых типов - это просто списки уникальных имен или
					идентификаторов, зарезервированных с конкретной целью. Например, можно
					создать тип MyColor (мой цвет) со значениями myRed, myGreen и myBlue (мой
					красный, мой зеленый, мой синий). Это делается совсем просто:
					<br/>
					Type MyColor = (myRed, myGreen, myBlue);
					<br/>
					В этой строке объявлены четыре новых идентификатора: MyColor, myRed,
					myGreen и myBlue. идентификатором MyColor обозначен порядковый тип,
					следовательно, в синтаксисе Object Pascal можно применять этот
					идентификатор везде, где разрешены перечислимые типы. Остальные три
					идентификатора- это значения типа MyColor. Подобно символьным и булевым
					типам перечислимые не являются числами, и использовать их наподобие чисел
					не имеет смысла. Однако перечислимые типы относятся к порядковым, так что
					значения любого такого типа упорядочены. Идентификаторам в списке
					присваиваются в качестве порядковых номеров последовательные числа. Первому
					имени присваивается порядковый номер 0, второму - 1 и т.д.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					В С и C++ есть тип enema, аналогичный перечислимому типу Delphi. Но в этих
					языках можно произвольно присваивать идентификаторам постоянные значения. В
					Delphi же соответствие имен и их значений фиксиро-вано: первому имени
					присваивается значение 0, каждому последующему - на единицу больше. В С тип
					enum применяется лишь как средство быстрого определения набора целых
					постоянных. В C++ объявленные в перечислимом типе идентификаторы можно
					присваивать только переменным того же типа.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<a name="6"></a>
					<strong>Поддиапазонные типы</strong>
					<br/>
					Переменные поддиапазонного типа содержат информацию, соответствующую
					некоторому pаданному диапазону значений исходного типа, представляющего
					любой порядковый тип, кроме поддиапазонного. Синтаксис определения
					поддиапазонного типа имеет следующий вид:

				</p>
				<p>
					Type subrange type = low value...high value;

				</p>
				<p>
					Поддиапазонные переменные сохраняют все особенности исходного типа.
					Единственное отличие состоит в том, что переменной поддиапазонного типа
					можно присваивать только значения, входящие в заданный поддиапазон.
					Контроль за соблюдением этого условия задается командой проверки диапазона
					(range checking).
					<br/>
					Необходимость явно определять поддиапазонный тип возникает нечасто, но все
					программисты неявно применяют эту конструкцию при определении массивов.
					Именно в форме поддиапазонной конструкции задается схема нумерации
					элементов массива.

				</p>
				<p>
					<a name="7"></a>
					<strong>Действительные типы</strong>
					<br/>
					В переменных действительных типов содержатся числа, состоящие из целой и
					дробной частей. В Object Pascal определено шесть действительных типов. Все
					типы могут представлять число 0, однако они различаются пороговым
					(минимальным положительным) и максимальным значениями, которые могут
					представлять, а также точностью (количеством значащих цифр) и объемом.
					Действительные типы описываются в табл. 1.5.
					<br/>

				</p>
				<p>
					<strong>Таблица 1.5.</strong>
					Действительные типы.

				</p>
				<p>

				</p>
				<div align="right">
					<table border="1" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										<strong>Тип</strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Порог </strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Максимальное значение </strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Количество значащих цифр </strong>
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										<strong>Объем (байт)</strong>
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Real
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										2.9E-39
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1.7Е38
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										11-12
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										6
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Single
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1.5E-45
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										3.4Е38
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										7-8
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										4
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Double
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										5.0E-324
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1.7Е308
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										15-16
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										8
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Extended
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										3.4E-4932
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1.IE4932
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										19-20
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										10
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Comp
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										1.0
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										9.2Е18
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										19-20
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										8
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Currency
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										0.0001
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										9.2Е14
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										19-20
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										8
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					Тип Real предназначен для совместимости с ранними версиями Delphi и Borland
					Pascal. Формат этого типа неудобен для семейства процессоров Intel, поэтому
					операции с типом Real выполняются несколько медленнее операций над
					остальными действительными типами.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					Целые типы представляют целые числа, т.е. числа, дробная часть которых
					равна нулю. Разница между двумя неодинаковыми целыми числами не может быть
					меньше единицы. Именно благодаря этому целые числа применяются для
					обозначения дискретных величин, независимо от того, имеют ли реальные
					объекты какое-либо отношение к числам. Действительные типы предназначены
					для представления чисел, которые могут иметь дробную часть, поэтому они
					полезны для представления величин, которые могут быть довольно близкими,
					почти непрерывными.
					<br/>
					Заметьте, именно почти. Несмотря на название действительные, переменные
					этих типов отличаются от математических действительных чисел. В Object
					Pascal действительный тип - это подмножество математических действительных
					чисел, которые можно представить в формате с плавающей запятой и
					фиксированным числом цифр. Для невнимательных программистов ситуация
					усугубляется тем, что в стандартных форматах IEEE (Institute of Electrical
					and Electronic Engi-neers - Институт инженеров- электриков и
					электронщиков), применяемых в программах Delphi и вообще в большинстве
					программ для Windows, возможно точное представление только чисел с
					фиксированным числом бит в дробной части. Удивительно, но такое простое
					число, как 0,1, записывается в расширенном формате IEEE с некоторой
					погрешностью, пусть очень небольшой. Из-за этого представление с плавающей
					запятой оказывается несколько неудобным для программ, в которых сохраняется
					и выводится фиксированное число десятичных разрядов численных значений. Это
					относится и к программам, работающим с ''живыми" деньгами.
					<br/>
					Для частичного решения этой проблемы в Object Pascal определены два формата
					с фиксированной запятой. Тип Comp (computational - вычислительный) содержит
					только целые числа в диапазоне от -2<sup>63</sup>+1 до 2<sup>63</sup>-1,
				что примерно соответствует диапазону от -9,2х10<sup>18</sup> до 9,2х10	<sup>18</sup>. При программировании операций с американской валютой
					разработчикам обычно приходится искать естественный способ записи денежных
					сумм, в котором целая часть числа определяет количество долларов, дробная -
					центов. Если такие значения записывать в переменные типа Comp, придется
					представлять их в виде целого числа центов. В этом случае следует умножать
					значение на 100 для обращения центов в доллары, а затем делить на 100,
					чтобы снова получить центы.
					<br/>
					Этих забот можно избежать, если воспользоваться типом Currency. В этом
					случае задачу выбора масштаба возьмет на себя компилятор. Физически
					значения Currency записываются в память того же объема, что и Comp, как
					целые числа, однако компилятор не забывает вовремя разделить значение на 10
					000 (не на 100!) для его приведения в соответствие с денежным знаком и
					умножить на 10 000 перед записью в память. Это обеспечивает абсолютную
					точность в четыре десятичных знака после запятой.
					<br/>
					В Delphi есть модуль System, содержащий ряд процедур обработки данных
					действительных типов. Наиболее распространенные из них перечислены в табл.
					1.6. Много полезных процедур содержится также в модулях SysUtils и Math.
					<br/>

				</p>
				<p>
					<strong>Таблица 1.6.</strong>
					Функции действительных типов

				</p>
				<div align="right">
					<table border="1" cellpadding="0" width="93%">
						<tbody>
							<tr>
								<td>
									<p>
										Функция
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Возвращаемое значение
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Abs (x)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Абсолютная величина х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										АгсТаn(х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Арктангенс х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Cos (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Косинус х (х выражается в радианах, а не в градусах)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Ехр (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Экспоненциальная функция от х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Frac(x)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Дробная часть х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Int (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Целая часть х. Несмотря на название, возвращает
										действительное значение (с плавающей запятой), т.е.
										просто устанавливает нуль в дробной части
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Ln (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Натуральный логарифм от х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Pi
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Число Пи (3.1416...)
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Round (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Ближайшее к х целое значение. Возвращает значение
										целого типа. Условие "ближайшее к х" не работает, если
										верхнее и нижнее значения оказываются равноудаленными
										(например, ес-ли дробная часть точно равна 0,5). В этих
										случаях Delphi перекладывает решение на опера-ционную
										систему. Обычно процессоры Intel решают эту задачу в
										соответствии с рекоменда-цией IEEE округлять в сторону
										ближайшего четного целого числа. Иногда такой подход
										на-зывают "банкирским округлением"
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Sin(x)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Синус х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Sqr(x)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Квадрат х, т.е. X*X
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Sqrt (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Квадратный корень от х
										<p>
										</p>
									</p>
								</td>
							</tr>
							<tr>
								<td>
									<p>
										Тrunc (х)
										<p>
										</p>
									</p>
								</td>
								<td>
									<p>
										Целая часть х. В отличие от Int, возвращающей
										действительное значение, Trunc возвращает целое
										<p>
										</p>
									</p>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
				</div>
				<p>
					<br/>
					<strong>Совет: </strong>
					Будьте внимательны при переносе численных выражений из одного языка в
					другой. В Basic функция SQR вычисляет квадратный корень, а функция Sqr из
					Delphi - квадрат числа. Для вычисления квадратного корня в Delphi
					применяется функция Sqrt.

				</p>
				<div align="center">
					<hr size="2" width="100%" align="center"/>
</div>
			</article>	
		</main>
		<footer class="footer">
			<div></div>
		</footer>
		<script src="../../scripts.js"></script>
	</body>
</html>