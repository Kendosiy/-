<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link href="../../style.css" rel="stylesheet">
	</head>
	<body>
		<header>
			<div>
				<a href="../../index.html"><h1>Учебный портал</h1></a>
			</div>
			<nav>
					<ul class="main_menu">
					<li>
<<<<<<< HEAD
<<<<<<< HEAD
						<a href="#"><p>Справочные материалы</p></a>
=======
						<a href="#"><p>Справочные материалы&#9207;</p></a>
>>>>>>> f12edd62888d7f1067e2a4e99743dfe436d13998
=======
						<a href="#"><p>Справочные материалы&#9207;</p></a>
>>>>>>> f12edd62888d7f1067e2a4e99743dfe436d13998
						<ul class="submenu" id="sub1">
							<li><a href="../../delphi-lab-teor.html">Теория по Delphi</a></li>
						</ul>
					</li>
					<li>
<<<<<<< HEAD
<<<<<<< HEAD
						<a href="#"><p>Лабораторные работы</p></a>
=======
						<a href="#"><p>Лабораторные работы&#9207;</p></a>
>>>>>>> f12edd62888d7f1067e2a4e99743dfe436d13998
=======
						<a href="#"><p>Лабораторные работы&#9207;</p></a>
>>>>>>> f12edd62888d7f1067e2a4e99743dfe436d13998
						<ul class="submenu" id="sub2">
							<li><a href="../../delphi-lab-prac.html">Задания по Delphi</a></li>
						</ul>
					</li>
				</ul>
			</nav>
		</header>
		<main>
			<div class="prev"><a href="tema2.html"><img src="../../res/prev.png"></a></div>
			<div class="next"><a href="tema4.html"><img src="../../res/next.png"></a></div>
			<aside id="sidebar">
				<h2>Быстрая навигация</h2>
				<ol>
					<li><a href="#1">Режим пера</a></li>
					<li><a href="#2">Рисуем в форме</a></li>
					<li><a href="#3">Рисуем в оперативной памяти</a></li>
					<li><a href="#4">функция ScanLine</a></li>
				</ol>
			</aside>
			<article class="tema">
				<h2>
					Класс Точечное изображение (
					Tbitmap
					)]
				</h2>
				<p>
					Это специальный класс, с помощью которого можно хранить, загружать из
					файла, или буфера обмена Windows, сохранять в файле или буфере обмена
					графические точечные изображения в формате битовой карты (расширение .bmp)
				</p>
				<p>
					<strong>Анимация.</strong>
				</p>
				<p>
					Чтобы изобразить движение, можно использовать несколько способов.
				</p>
				<p>
					Один из них – изображение рисунка, стирание его, изображение со смещением.
					Чтобы стереть рисунок, созданный с помощью пера, можно воспользоваться
					режимом pmNotXor.
				</p>
				<h3>
					Логические операции с цветом
				</h3>
				<p>
					Обычный режим рисования предполагает, что цвет рисунка соответствует цвету
					рисующего инструмента - в какую краску макнули перо или кисть, такой цвет и
					увидим. Существуют и специальные режимы рисования, при которых цвет
					инструмента взаимодействует с цветом фона, подобно тому, как синий карандаш
					на желтом фоне оставляет зеленый след. Сейчас речь пойдет о применяемых к
					цветовым кодам операциях, которые позволяют получать удивительные эффекты,
					вплоть до полного стирания изображения. Такие возможности позволяют
					экономить не только память, но и время, что важно, например, при написании
					программ анимации.
					<br/>
					Значение двоичного разряда 1 можно трактовать как true, а 0 - как false, и
					тогда над двоичными кодами можно производить логические операции, применяя
					их к каждому двоичному разряду. Эта идея реализована в специальных режимах
					рисования. Свойство Mode (режим) пера Pen (из набора средств рисования
					Canvas) предусматривает различные логические операции над битами цветового
					кода фонового изображения и битами цветового кода изображения, рисуемого
					пером. Здесь мы рассмотрим лишь одну из таких операций, с остальными можно
					познакомиться в оперативной справке системы Delphi.
				</p>
				<a name="1"></a>
				<h2>
					Режим пера pmNotXor
				</h2>
				<p>
					В табл. 10.1 показаны результаты некоторых логических операций над
					логическими операндами а , b и с = NOT (a XOR b), принимающими одно из двух
					возможных значений 1 (true) и 0 (false).
				</p>
				<p>
					<strong>Табл. 10.1.</strong>
					Результаты логических операций над операндами
				</p>
				<table border="1" cellpadding="0" width="0">
					<tbody>
						<tr>
							<td>
								<p>
									a
								</p>
							</td>
							<td>
								<p>
									B
								</p>
							</td>
							<td>
								<p>
									a XOR b
								</p>
							</td>
							<td>
								<p>
									c=NOT (a XOR b)
								</p>
							</td>
							<td>
								<p>
									a XOR c
								</p>
							</td>
							<td>
								<p>
									NOT (a XOR c)
								</p>
							</td>
						</tr>
						<tr>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
						</tr>
						<tr>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
						</tr>
						<tr>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
						</tr>
						<tr>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
							<td>
								<p>
									0
								</p>
							</td>
							<td>
								<p>
									1
								</p>
							</td>
						</tr>
					</tbody>
				</table>
				<p>
				Поскольку таблица охватывает все возможные комбинации значений	<strong>a</strong> и <strong>b</strong>, то на основе этой таблицы делаем
				следующие выводы. Разовое применение составной логической операции	<strong>NOT</strong> <strong>(a XOR b) </strong>в случае <strong>а</strong>
					= 1 не меняет значение <strong>b</strong>, а в случае <strong>а</strong> =
					0 меняет значение <strong>b</strong> на противоположное. Повторное
				применение этой же операции: <strong>NOT</strong><strong>(a XOR (NOT (a XOR b)))</strong> восстанавливает значение	<strong>b</strong> независимо от значения а.
					<br/>
					Таким образом, побитовое использование этой операции - ей соответствует
					режим пера pmNotXor - приводит к любопытным цветовым эффектам. Предположим,
				в переменной <strong>А</strong> типа TСolor содержится код синего цвета -<strong>А</strong>: 11111111 00000000 00000000 , а в переменной	<strong>В</strong> того же типа - код красного цвета: <strong>В</strong>:
					00000000 00000000 11111111.
					<br/>
					Результат операции <strong>NOT (А XOR В)</strong> дает код зеленого цвета:
					<strong>
						<br/>
						С= NOT (А XOR В)
					</strong>
					: 00000000 11111111 00000000,
					<br/>
					повторное же взаимодействие кода <strong>А</strong> с полученным
				результатом опять возвращает код красного цвета:	<strong>NOT (А XOR С)</strong>: 00000000 00000000 11111111.
					<br/>
					Эта чудесная возможность позволяет создавать динамически изменяющиеся
					цветные изображения, не беспокоясь о сохранении и восстановлении
					закрываемого этим изображением фона. Достаточно в режиме пера pmNotXor
					дважды нарисовать изображение в одном и том же месте. Первый раз оно
					появится, второй раз - исчезнет, не оставив и следа!
					<br/>
					Следующий эксперимент демонстрирует анимационные эффекты, основанные на
					этой технике рисования.
					<strong>
						<br/>
						Эксперимент 1
					</strong>
					. Создадим новый проект. В форме поместим кнопку Button1, в заголовке
					которой напишем ПУСК. При щелчке на кнопке в форме появится изображение
					планеты с вращающимся вокруг нее спутником. Планета отбрасывает цветную
					сине-зеленую тень. При входе в эту тень спутник меняет свою окраску.
				</p>
				<p>
					<strong>procedure</strong>
					TForm1.Button1Click(Sender:TObject);<strong> </strong>
				</p>
				<p>
					<strong>const</strong>
				</p>
				<p>
					N=3; // количество оборотов
				</p>
				<p>
					// спутника
				</p>
				<p>
					dt=2*pi/1000; // приращение угла
				</p>
				<p>
					// поворота
				</p>
				<p>
					r=120; // радиус орбиты
				</p>
				<p>
					rp=100; // радиус планеты
				</p>
				<p>
					rc=7; // радиус спутника
				</p>
				<p>
					xp=200; // координаты центра планеты
				</p>
				<p>
					yp=150;<strong> </strong>
				</p>
				<p>
					<strong>var</strong>
				</p>
				<p>
					t:real; // угол поворота
				</p>
				<p>
					xc,yc:integer; //координаты центра
				</p>
				<p>
					// спутника<strong> begin</strong>
				</p>
				<p>
					<strong>with</strong>
					Form1.Canvas <strong>do</strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					Brush.Color:=RGB(0,255,0);
				</p>
				<p>
					FillRect(Rect(xp,yp-rp,Form1.Width,
				</p>
				<p>
					yp+rp)); // Рисуем зеленую тень.
				</p>
				<p>
					Brush.Color:=clBlue;
				</p>
				<p>
					FillRect(Rect(xp,yp-rp <strong>div</strong>
				</p>
				<p>
					2,Form1.Width,yp+rp <strong>div</strong> 2));
				</p>
				<p>
					// Рисуем синюю тень.
				</p>
				<p>
					Brush.Color:=RGB(10,50,150);
				</p>
				<p>
					Pen.Mode:=pmCopy; // Устанавливаем
				</p>
				<p>
					// обычный режим рисования.
				</p>
				<p>
					Pen.Color:=clBlue; // Цвет контура
				</p>
				<p>
					// планеты - синий.
				</p>
				<p>
					Pen.Width:=1;
				</p>
				<p>
					Ellipse(xp - rp,yp - rp,xp+rp,yp+rp);
				</p>
				<p>
					// Рисуем планету.
				</p>
				<p>
					Pen.Color:=clRed; // Устанавливаем
				</p>
				<p>
					// параметры для рисования спутника.
				</p>
				<p>
					Pen.Width:=2*rc;
				</p>
				<p>
					Pen.Mode:=pmNotXor; // Устанавливаем
				</p>
				<p>
					// режим пера pmNotXor.
				</p>
				<p>
					t:=pi;
				</p>
				<p>
					<strong>while</strong>
					t&lt;2*pi*N+pi <strong>do</strong> // Цикл движения
				</p>
				<p>
					// спутника по орбите.
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					t:=t+dt;
				</p>
				<p>
					xc:=xp+round(r*cos(t));
				</p>
				<p>
					// Рассчитываем текущие координаты
				</p>
				<p>
					// спутника.
				</p>
				<p>
					yc:=yp+round(r*sin(t));
				</p>
				<p>
					Ellipse(xc - rc,yc - rc,xc+rc,yc+rc);
				</p>
				<p>
					// Первый раз рисуем спутник.
				</p>
				<p>
					Sleep(10); // Пауза 10 миллисекунд.
				</p>
				<p>
					Ellipse(xc - rc,yc - rc,xc+rc,yc+rc);
				</p>
				<p>
					// Рисуем второй раз, и,
				</p>
				<p>
					// благодаря режиму pmNotXor, тем
				</p>
				<p>
					// самым затираем изображение.
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					<strong>end</strong>
					;<strong> </strong>
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					Другие возможности взаимодействия цвета изображения и фона реализованы в
					свойстве CopyMode набора средств рисования Canvas
				</p>
				<a name="2"></a>
				<h2>
					Рисуем в форме
				</h2>
				<p>
					В следующем эксперименте мы воспользуемся описанной выше побайтовой
					структурой цветового кода для рисования в компоненте Image1.
				</p>
				<p>
					<br/>
					<strong>Эксперимент 1. </strong>
					Разместим в форме компонент <strong>Image1</strong> (с вкладки Additional)
					и установим его размеры Width: 201; Height: 201. Добавим кнопку Button1, в
					заголовке которой напишем: "Рисуем в Image1". При щелчке на этой кнопке
					произойдет попиксельная закраска изображения <strong>Image1</strong> в виде
					некоторого узора.
					<br/>
					Нам понадобится вспомогательная функция CLR, специальным образом
					вычисляющая цвет пиксела. Приведенный ниже код функции CLR следует
				разместить после строки <strong>{$R *.DFM}</strong> в модуле	<strong>Unit1</strong>.
				</p>
				<p>
					<strong>function</strong>
					CLR(n,k:integer):TColor;<strong> </strong>
				</p>
				<p>
					<strong>var</strong>
				</p>
				<p>
					g:byte;<strong> </strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					g:=1+n <strong>mod</strong> 15;
				</p>
				<p>
					<strong>case</strong>
					k <strong>of</strong>
				</p>
				<p>
					0: CLR:=$001111*g;
				</p>
				<p>
					1: CLR:=$000011*g;
				</p>
				<p>
					2: CLR:=$001100*g;
				</p>
				<p>
					3: CLR:=$110000*g;
				</p>
				<p>
					4: CLR:=$110011*g;
				</p>
				<p>
					5: CLR:=$111100*g;
				</p>
				<p>
					6: CLR:=$111111*g;
				</p>
				<p>
					<strong>end</strong>
					;<strong> </strong>
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					Локальная переменная g стандартного типа byte (беззнаковое целое в
					диапазоне от 0 до 255) используется здесь для задания интенсивности
					соответствующего цветового оттенка. Целочисленные формальные параметры n и
				k регулируют выбор цвета. Нам в дальнейшем понадобится также	<em>глобальная </em>переменная <strong>k</strong>, описание которой нужно
					разместить перед описанием функции CLR:
				</p>
				<p>
					var k: integer = -1;
				</p>
				<p>
					Ниже приводится текст процедуры-реакции на щелчок на кнопке Button1.
				</p>
				<p>
					<strong>procedure</strong>
					TForm1.Button1Click(Sender:TObject);<strong> </strong>
				</p>
				<p>
					<strong>var</strong>
				</p>
				<p>
					i,j,io: integer;
				</p>
				<p>
					c: TColor;
				</p>
				<p>
					Tick: Cardinal;<strong> </strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					Tick:= GetTickCount;
				</p>
				<p>
					inc(k);
				</p>
				<p>
					k:=k <strong>mod</strong> 7;
				</p>
				<p>
					io:= Image1.Height <strong>div</strong> 2;
				</p>
				<p>
					<strong>for</strong>
					i:=0 <strong>to</strong> io <strong>do</strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					<strong>for</strong>
					j:=0 <strong>to</strong> io <strong>do</strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					c:=CLR(i*j+random(11), k);
				</p>
				<p>
					Image1.Canvas.Pixels[io+i, io+j]:=c;
				</p>
				<p>
					Image1.Canvas.Pixels[io-i, io+j]:=c;
				</p>
				<p>
					Image1.Canvas.Pixels[io+i, io-j]:=c;
				</p>
				<p>
					Image1.Canvas.Pixels[io-i, io-j]:=c;
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					Application.ProcessMessages;
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					Caption:=IntToStr(GetTickCount -Tick);<strong> </strong>
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					В этой процедуре происходит закраска пикселов, расположенных симметрично
					относительно горизонтальной и вертикальной осей симметрии квадратной
					области Image1 специально выбираемым цветом. При расчете цвета для большей
					художественности изображения использована небольшая "размывка" цветового
					кода с помощью датчика случайных чисел random. Для качественной работы
					этого датчика в конце программы (перед <strong>end.</strong> с точкой)
					следует добавить новый раздел:
				</p>
				<p>
					<strong>initialization</strong>
				</p>
				<p>
					randomize;
				</p>
				<p>
					Для контроля времени исполнения в процедуре вызывается стандартная функция
					GetTickCount (ее описание приводится в главе 8).
					<br/>
					Многократно щелкая на кнопке Button1, можно получать разнообразные
					орнаменты. На рис. 10.1 показан один из таких удивительных узоров. К
					сожалению, рисунок черно-белый, но на экране своего монитора вы увидите
					нечто гораздо более впечатляющее. Испытайте другие настройки цветовых
					оттенков, добавив, например, в перечень цветовых кодов функции CLR числа
					$00BFFF, $711100 и прочие.
				</p>
				<p align="center">
					<img
						width="201"
						height="200"
						src="tema3/image001.gif"
					/>
					<br/>
					<strong>Рис. 10.1. </strong>
					Рисунок, полученный с помощью попиксельной закраски
				</p>
				<p>
					Основное замечание по этой программе: прорисовка изображения происходит с
					некоторым замедлением. На компьютере Pentium-100 область Image1
					прорисовывается около 6 секунд. На более мощных компьютерах эффект
					замедления также проявится, если увеличить размеры Image1. С более
					скоростной техникой рисования растровых изображений мы познакомимся в двух
					следующих экспериментах.
				</p>
				<a name="3"></a>
				<h2>
					Рисуем в оперативной памяти
				</h2>
				<p>
					Котлеты можно приготовить в домашних условиях, а можно воспользоваться уже
					имеющимися полуфабрикатами. Точно так же в форму можно загрузить уже
					готовое изображение, которое мы предварительно нарисуем в памяти. Как и в
					случае с котлетами, это будет быстрее.
					<strong>
						<br/>
						Эксперимент 2
					</strong>
					. Добавим в форму кнопку Button2, в заголовке которой напишем: "Используем
					память". В Delphi имеется специальный класс растровых изображений TBitmap,
					которые можно формировать непосредственно в оперативной памяти компьютера.
					Целиком сформированное в памяти изображение гораздо быстрее переносится в
					форму, чем попиксельное рисование в самой форме. Реакция на щелчок на
					кнопке Button2 описана в следующей процедуре.
				</p>
				<p>
					<strong>procedure</strong>
					TForm1.Button2Click(Sender:TObject);<strong> </strong>
				</p>
				<p>
					<strong>var</strong>
				</p>
				<p>
					i,j,io: integer;
				</p>
				<p>
					c: TColor;
				</p>
				<p>
					Btm: TBitmap;
				</p>
				<p>
					Tick: Cardinal;<strong> </strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					Tick:= GetTickCount;
				</p>
				<p>
					Btm:=TBitmap.Create;
				</p>
				<p>
					Btm.Height:=Image1.Height;
				</p>
				<p>
					Btm.Width:=Image1.Width;
				</p>
				<p>
					inc(k);
				</p>
				<p>
					k:=k <strong>mod </strong>7;
				</p>
				<p>
					io:= Btm.Height <strong>div</strong> 2;<strong> </strong>
				</p>
				<p>
					<strong>for</strong>
					i:=0 <strong>to</strong> io <strong>do </strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					<strong>for</strong>
					j:=0 <strong>to</strong> io <strong>do</strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					c:=CLR (i*j+random(11), k);
				</p>
				<p>
					Btm.Canvas.Pixels[io+i, io+j]:=c;
				</p>
				<p>
					Btm.Canvas.Pixels[io-i, io+j]:=c;
				</p>
				<p>
					Btm.Canvas.Pixels[io+i, io-j]:=c;
				</p>
				<p>
					Btm.Canvas.Pixels[io-i, io-j]:=c;
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					Image1.Picture.Bitmap.Assign(Btm);
				</p>
				<p>
					Btm.Free;
				</p>
				<p>
					Caption:=IntToStr(GetTickCount -Tick);<strong> </strong>
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					В этой процедуре происходит почти то же самое, что и ранее, однако пикселы
					закрашиваются не в компоненте Image1, а в битовой карте с придуманным нами
					именем Btm. Карта Btm типа TBitmap располагается в памяти компьютера. В
				начале работы процедуры после вызова <em>конструктора</em>	<strong>Btm:=TBitmap.Create</strong> для этой карты выделяется оперативная
				память. Ее нужно освободить в конце работы процедуры:	<strong>Btm.Free</strong>. Копирование изображения из оперативной памяти в
					компонент Image1 происходит при вызове метода <strong>Assign</strong>
					(назначить):
				</p>
				<p>
					Image1.Picture.Bitmap.Assign(Btm);
				</p>
				<p>
				Время исполнения этой процедуры по сравнению с процедурой	<strong>TForm1.Button1Click</strong> сокращается примерно в 5 раз и на
					компьютере Pentium 100 составляет около одной секунды.
				</p>
				<a name="4"></a>
				<h2>
					Функция ScanLine
				</h2>
				<p>
					Наиболее скоростным средством при обращении с растровыми изображениями
					является функция ScanLine. Она просматривает строку битовой карты. Если
					каждый пиксел такой строки представить в виде совокупности трех
					"вагончиков" - байтов - на красную, зеленую и синюю составляющую цвета по
					одному "вагончику", то функция ScanLine помогает сформировать из этих
					"вагончиков" целый "поезд". Манипулировать же целыми "поездами" оказывается
					гораздо быстрее, чем отдельными "вагончиками".
					<strong>
						<br/>
						Эксперимент 3
					</strong>
					. Добавим в форму кнопку Button3 и напишем в ее заголовке ScanLine.
					Обработчик щелчка мышью на этой кнопке приводится ниже.
				</p>
				<p>
					<strong>procedure</strong>
					TForm1.Button3Click(Sender:TObject);<strong> </strong>
				</p>
				<p>
					<strong>var</strong>
				</p>
				<p>
					i,j,io: integer;
				</p>
				<p>
					c: TColor;
				</p>
				<p>
					Bmp: TBitmap;
				</p>
				<p>
					Line1,Line2: pByteArray;
				</p>
				<p>
					Tick: Cardinal;<strong> </strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					Tick:= GetTickCount;
				</p>
				<p>
					Bmp:=Image1.Picture.Bitmap;
				</p>
				<p>
					Bmp.PixelFormat:=pf24bit;
				</p>
				<p>
					Bmp.Width:=Image1.Width;
				</p>
				<p>
					Bmp.Height:=Image1.Height;
				</p>
				<p>
					inc(k);
				</p>
				<p>
					k:=k <strong>mod</strong> 7;
				</p>
				<p>
					io:= Bmp.Height <strong>div</strong> 2;
				</p>
				<p>
					<strong>for</strong>
					i:=0 <strong>to</strong> io <strong>do</strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					<strong>if</strong>
					odd(Bmp.Height) <strong>then</strong>
				</p>
				<p>
					Line1:=PByteArray(Bmp.ScanLine[io+i])
				</p>
				<p>
					<strong>else</strong>
					Line1:=PByteArray
				</p>
				<p>
					(Bmp.ScanLine[io+i-1]);
				</p>
				<p>
					Line2:=PByteArray(Bmp.ScanLine[io-i]);
				</p>
				<p>
					<strong>for</strong>
					j:=0 <strong>to</strong> io <strong>do</strong>
				</p>
				<p>
					<strong>begin</strong>
				</p>
				<p>
					c:=CLR (i*j+random(11), k);
				</p>
				<p>
					Line1[(io+j)*3]:=GetBValue(c);
				</p>
				<p>
					Line1[(io-j)*3]:=GetBValue(c);
				</p>
				<p>
					Line2[(io+j)*3]:=GetBValue(c);
				</p>
				<p>
					Line2[(io-j)*3]:=GetBValue(c);
				</p>
				<p>
					Line1[(io+j)*3+1]:=GetGValue(c);
				</p>
				<p>
					Line1[(io-j)*3+1]:=GetGValue(c);
				</p>
				<p>
					Line2[(io+j)*3+1]:=GetGValue(c);
				</p>
				<p>
					Line2[(io-j)*3+1]:=GetGValue(c);
				</p>
				<p>
					Line1[(io+j)*3+2]:=GetRValue(c);
				</p>
				<p>
					Line1[(io-j)*3+2]:=GetRValue(c);
				</p>
				<p>
					Line2[(io+j)*3+2]:=GetRValue(c);
				</p>
				<p>
					Line2[(io-j)*3+2]:=GetRValue(c);
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					Image1.Invalidate;
				</p>
				<p>
					Caption:=IntToStr(GetTickCount-Tick);<strong> </strong>
				</p>
				<p>
					<strong>end</strong>
					;
				</p>
				<p>
					К этой программе необходим комментарий. В разделе локальных переменных
					наряду с объектами, которые описывались в предыдущих процедурах, добавлены
					переменные <strong>Line1</strong>, <strong>Line2</strong> - это имена двух
					"поездов", составленных из байтов с кодами красного, зеленого и синего
					цвета. Переменные <strong>Line</strong> и <strong>Line2</strong> имеют
				специальный тип pByteArray. Его можно расшифровать следующим образом:	<strong>Byte Array</strong> - это массив байтов, р - первая буква
					служебного слова pointer - указатель. Об указателях более подробно речь
				будет вестись в гл. 12. В строке	<strong>Bmp:=Image1.Picture.Bitmap</strong> создается копия указателя на
				битовую карту изображения Image1. Далее оператор	<strong>Bmp.PixelFormat:=pf24bit</strong> устанавливает, что каждый из трех
					основных цветов будет выражаться кодом из 8 бит. Конструкция вида
				</p>
				<p>
					Line1:=PByteArray(Bmp.ScanLine[n])
				</p>
				<p>
					формирует ссылку на байтовый массив n-ой строки пикселов битовой карты с
					указателем Bmp. Стандартные функции GetBValue, GetGValue, GetBValue
					извлекают коды синей, зеленой и красной составляющей цвета. Эти коды
					размещаются в три соседних "вагончика", для чего используется специальная
					индексация "вагончиков", например:
				</p>
				<ul type="disc">
					<li>
						<strong>Line1[(io+j)*3] </strong>
						- первый вагончик триады;
					</li>
					<li>
						<strong>Line1[(io+j)*3+1]</strong>
						- второй вагончик триады;
					</li>
					<li>
						<strong>Line1[(io+j)*3+2]</strong>
						- третий вагончик триады.
					</li>
				</ul>
				<p>
					Обязательной командой при работе с функцией ScanLine должна быть
					перерисовка сформированного в оперативной памяти изображения в компонент
					Image1: <strong>Image1.Invalidate;</strong>
					<br/>
				Несмотря на то что количество строк в процедуре<strong>TForm1.Button3Click</strong> по сравнению с	<strong>TForm1.Button1Click</strong> увеличилось чуть ли не вдвое, время ее
					исполнения сокращается в фантастическое количество раз. Теперь для закраски
					все того же поля Image1 требуется всего-навсего 30 миллисекунд!
				</p>
			</article>	
		</main>
		<footer class="footer">
			<div></div>
		</footer>
		<script src="../../scripts.js"></script>
	</body>
</html>